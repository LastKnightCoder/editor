# 白板路径转换算法文档

## 🎯 算法概述

白板路径转换算法解决了在批量操作中维护元素路径一致性的核心问题。当用户同时执行多个操作（插入、删除、移动、设置）时，确保每个操作的路径在执行时仍然有效。

### 核心挑战

- **路径失效**：删除操作可能使其他操作的目标路径无效
- **顺序依赖**：操作执行顺序影响最终结果
- **路径更新**：前序操作会改变后续操作的有效路径

### 解决方案

三步处理流程：**过滤** → **排序** → **转换**

## 🔧 算法实现

### 第一步：操作过滤 (`filterValidOperations`)

**目标**：移除因祖先删除而无效的操作

**策略**：

1. 预先收集所有删除操作路径
2. 过滤掉目标路径是删除路径后代的操作
3. 特殊处理Move操作的源路径和目标路径

```typescript
// 示例：删除[0]会使插入[0,1]无效
operations = [
  { type: 'insert_node', path: [0, 1], node: {...} },  // 无效
  { type: 'remove_node', path: [0], node: {...} }      // 有效
]
// 结果：只保留删除操作
```

### 第二步：操作排序 (`sortOperationsForExecution`)

**目标**：确保操作执行的依赖关系正确

**排序规则**：

```
1. 操作类型优先级：其他操作 → 插入 → 设置 → 删除
2. 插入操作：深度浅→深，同层索引小→大（保证父元素先于子元素插入）
3. 删除操作：深度深→浅，同层索引大→小（保证undo时的插入顺序正确）
```

**排序原因**：

- **插入排序**：确保插入子元素时父元素已存在
- **删除排序**：确保undo操作（删除的逆操作是插入）时父子顺序正确

```typescript
// 插入操作示例：父元素必须先插入
[
  { type: 'insert_node', path: [0, 1], node: {...} },  // 子元素
  { type: 'insert_node', path: [0], node: {...} }      // 父元素
]
// 排序后：先插入[0]父元素，再插入[0,1]子元素

// 删除操作示例：为undo准备正确的插入顺序
[
  { type: 'remove_node', path: [0] },      // 父元素
  { type: 'remove_node', path: [0, 1] }    // 子元素
]
// 排序后：先删[0,1]子元素，再删[0]父元素
// undo时：先插入[0]父元素，再插入[0,1]子元素
```

### 第三步：路径转换 (`transformValidOperations`)

**目标**：将操作路径转换为执行时的实际有效路径

**过程**：

1. 按排序顺序逐个处理操作
2. 用当前操作更新后续所有操作的路径
3. 使用`transformPath`方法计算路径变化

## ⚙️ 核心方法：`transformPath`

### 插入操作影响

```typescript
// 在[1]位置插入，影响同级后续元素
[0] → [0]  // 不变
[1] → [2]  // +1
[2] → [3]  // +1
```

### 删除操作影响

```typescript
// 删除[1]位置，影响同级后续元素
[0] → [0]  // 不变
[2] → [1]  // -1
[3] → [2]  // -1
```

### Move操作影响 ⭐

**核心修复**：Move操作按原子操作处理，而非"先删后插"

#### 同级Move操作

```typescript
// Move [2] → [0]
[0] → [1]  // 为插入腾空间
[1] → [2]  // 为插入腾空间
[2] → [0]  // 被移动元素获得目标位置
[3] → [2]  // 填补删除的空间
```

#### 跨级Move操作

```typescript
// Move [0,1] → [1,0]
[0,1] → [1,0]  // 被移动元素
[0,2] → [0,1]  // 源路径同级：删除影响
[1,0] → [1,1]  // 目标路径同级：插入影响
[2,0] → [2,0]  // 无关路径不变
```

#### 祖先路径重构 🆕

**重要场景**：当`move_node`移动元素时，被移动元素的子路径需要重构祖先部分

```typescript
// Move [1,2] → [3,0]，影响子路径
[1,2] → [3,0]        // 被移动元素本身
[1,2,0] → [3,0,0]    // 子路径：祖先重构
[1,2,1] → [3,0,1]    // 子路径：祖先重构
[1,2,0,5] → [3,0,0,5] // 深层子路径：祖先重构

// 对于set_node操作的影响
move_node [0,1] → [2,3]
set_node [0,1,0] → [2,3,0]  // set操作路径跟随移动
```

## 🚀 性能与测试

### 性能指标

- **算法性能**：>4,000,000 ops/sec
- **时间复杂度**：O(n²) 最坏情况
- **空间复杂度**：O(n)

### 测试架构

```
📁 测试文件组织（69个测试）
├── PathTransformCore.test.ts      (12) - transformPath核心方法
├── PathTransform.basic.test.ts    (8)  - 基础转换场景
├── PathTransform.move.test.ts     (8)  - Move操作专项
├── PathTransform.move-set.test.ts (7)  - Move-Set操作集成测试 🆕
├── PathTransform.prefilter.test.ts(7)  - 过滤算法
├── PathTransform.parent.test.ts   (10) - 父子关系处理
├── FilterAndSort.test.ts          (9)  - 过滤排序算法
└── PathTransform.integration.test.ts(8) - 完整流程测试
```

**Move-Set集成测试涵盖场景**：

- 祖先路径重构：Move元素时其子路径的Set操作路径重构
- 复杂影响组合：祖先重构、同级影响、无关路径的综合处理
- 深层嵌套：多级子路径的正确重构
- 边界情况：相同路径、幂等性验证
- 同级移动：向前/向后移动对Set操作的不同影响

## 📖 使用指南

### 基本用法

```typescript
import { PathUtil } from "./PathUtil";

const operations = [
  { type: "remove_node", path: [0], node: { id: "1", type: "shape" } },
  { type: "insert_node", path: [1], node: { id: "2", type: "shape" } },
  { type: "move_node", path: [2], newPath: [0] },
];

// 完整处理流程
const validOps = PathUtil.filterValidOperations(operations);
const sortedOps = PathUtil.sortOperationsForExecution(validOps);
const transformedOps = PathUtil.transformValidOperations(sortedOps);

// 应用到白板
board.apply(transformedOps);
```

### 单步调试

```typescript
// 单独测试路径转换
const moveOp = { type: "move_node", path: [2], newPath: [0] };
const transformedPath = PathUtil.transformPath([1], moveOp);
console.log(transformedPath); // [2] - 原[1]被向后推移
```

## 🛠️ 关键修复历程

### 问题发现

**第一阶段**：

1. **Move操作完全失效** - `transformPath`方法未处理`move_node`
2. **根级路径识别错误** - `areSiblingPaths`不认为`[0]`和`[1]`是兄弟
3. **语义理解错误** - Move操作返回null而非目标位置

**第二阶段（祖先路径重构修复）**：4. **祖先路径重构缺失** - Move操作无法处理被移动元素的子路径5. **Move-Set组合失效** - `move_node`和`set_node`组合时路径转换错误

### 修复过程

**阶段一：基础Move修复**

1. **TDD驱动** - 先写正确测试定义预期行为
2. **算法重构** - 实现原子性Move操作处理
3. **边界修复** - 修复`areSiblingPaths`对根路径的处理

**阶段二：祖先路径重构** 4. **问题发现** - 通过新增测试用例发现祖先路径重构缺失 5. **算法增强** - 添加`isAncestorPath`检查和路径重构逻辑6. **集成测试完善** - 创建专门的Move-Set集成测试覆盖所有场景

### 最终成果

- ✅ Move操作完全支持（同级、跨级、祖先路径重构）
- ✅ Move-Set集成正确（7个专项集成测试）
- ✅ 性能优异（>4M ops/sec）
- ✅ 测试全覆盖（69个测试用例）
- ✅ 架构清晰（单一职责测试文件）

## 🔍 算法核心洞察

> **关键理解**：Move操作不是"先删后插"的复合操作，而是原子操作。被移动的元素应该获得目标位置，而不是返回null。

这一理解的转变是整个修复过程的关键突破点，确保了算法符合真实的业务需求而不是实现细节。
